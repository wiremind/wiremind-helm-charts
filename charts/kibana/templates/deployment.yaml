apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ template "kibana.fullname" . }}
  labels: {{ include "kibana.labels" . | nindent 4 }}
  {{- if .Values.annotations }}
  annotations:
    {{ .Values.annotations | toYaml | nindent 4 }}
  {{- end }}
spec:
  replicas: {{ .Values.replicas }}
  strategy:
{{ toYaml .Values.updateStrategy | indent 4 }}
  selector:
    matchLabels:
      app: {{ .Chart.Name }}
      release: {{ .Release.Name | quote }}
  template:
    metadata:
      labels:
        app: {{ .Chart.Name }}
        release: {{ .Release.Name | quote }}
        {{- range $key, $value := .Values.labels }}
        {{ $key }}: {{ $value | quote }}
        {{- end }}
      annotations:
        {{- if .Values.token.create }}
        checksum/token: {{ (include "kibana.es-token-value" .) | sha256sum }}
        {{- end }}
        {{- range $key, $value := .Values.podAnnotations }}
        {{ $key }}: {{ $value | quote }}
        {{- end }}
        {{/* This forces a restart if the configmap has changed */}}
        {{- if .Values.kibanaConfig }}
        configchecksum: {{ include (print .Template.BasePath "/configmap.yaml") . | sha256sum | trunc 63 }}
        {{- end }}
    spec:
      automountServiceAccountToken: {{ .Values.automountToken }}
{{- if .Values.priorityClassName }}
      priorityClassName: {{ .Values.priorityClassName }}
{{- end }}
      securityContext:
{{ toYaml .Values.podSecurityContext | indent 8 }}
      serviceAccount: {{ template "kibana.service-account" . }}
      {{- if .Values.hostAliases }}
      hostAliases: {{ toYaml .Values.hostAliases | nindent 6 }}
      {{- end }}
      volumes:
        - name: kibana-tokens
          emptyDir: {}
        {{- if .Values.elasticsearchCertificateSecret }}
        - name: elasticsearch-certs
          secret:
            secretName: {{ .Values.elasticsearchCertificateSecret }}
        {{- end }}
        {{- if .Values.kibanaConfig }}
        - name: kibanaconfig
          configMap:
            name: {{ template "kibana.fullname" . }}-config
        {{- end }}
        {{- range .Values.secretMounts }}
        - name: {{ .name }}
          secret:
            secretName: {{ .secretName }}
        {{- end }}
        {{- if .Values.elasticsearchCertificateSecret }}
        - name: elasticsearch-certs
          secret:
            secretName: {{ .Values.elasticsearchCertificateSecret }}
        {{- end }}
        {{- if .Values.extraVolumes }}
{{ toYaml .Values.extraVolumes | indent 8 }}
        {{- end }}
    {{- with .Values.nodeSelector }}
      nodeSelector:
{{ toYaml . | indent 8 }}
    {{- end }}
    {{- with .Values.affinity }}
      affinity:
{{ toYaml . | indent 8 }}
    {{- end }}
    {{- with .Values.tolerations }}
      tolerations:
{{ toYaml . | indent 8 }}
    {{- end }}
    {{- if .Values.imagePullSecrets }}
      imagePullSecrets:
{{ toYaml .Values.imagePullSecrets | indent 8 }}
    {{- end }}
      initContainers:
        {{- if .Values.token.create }}
        - name: create-token
          image: curlimages/curl:8.11.0
          imagePullPolicy: "{{ .Values.imagePullPolicy }}"
          command:
            - /bin/sh
          args:
            - -c
            - |
              K8S_CA="/run/secrets/kubernetes.io/serviceaccount/ca.crt"
              K8S_URL="https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT_HTTPS}"
              K8S_BEARER=$(cat /run/secrets/kubernetes.io/serviceaccount/token)
              K8S_SECRET_NAMESPACE="{{ .Release.Namespace }}"
              K8S_SECRET_NAME="{{ template "kibana.es-token" . }}"

              ES_AUTH="${ELASTICSEARCH_USERNAME}:${ELASTICSEARCH_PASSWORD}"
              ES_CA="$ELASTICSEARCH_SSL_CERTIFICATEAUTHORITIES"
              ES_URL_HEALTH="{{ .Values.elasticsearchHosts }}/_cluster/health?wait_for_status=yellow&timeout=10s"
              ES_URL="{{ .Values.elasticsearchHosts }}/_security/service/elastic/kibana/credential/token/{{ template "kibana.fullname" . }}"

              echo "Retrieving elasticsearch token for kibana"

              secret_response=$(curl -k --max-time 5 --silent --show-error \
                -X GET \
                --cacert "$K8S_CA" \
                -H "Authorization: Bearer $K8S_BEARER" \
                -H "Accept: application/json" \
                -H "Content-Type: application/json" \
                "$K8S_URL/api/v1/namespaces/$K8S_SECRET_NAMESPACE/secrets/$K8S_SECRET_NAME" \
              )

              token_base64=$(echo "$secret_response" | sed -n 's/.*"token": "\([^"]*\)".*/\1/p')

              token=""
              # Check if the token field is non-empty
              if [[ -n "$token_base64" ]]; then
                token=$(echo "$token_base64" | base64 -d 2>/dev/null)
              fi

              while true;
              do
                echo "Waiting for elasticsearch..."

                HTTP_CODE=""
                RESPONSE_HEALTH_CMD="curl -k --max-time 5 --silent --show-error -u $ES_AUTH $ES_URL_HEALTH"
                if [[ "$ES_CA" != "" ]]; then
                  RESPONSE_HEALTH_CMD="${RESPONSE_HEALTH_CMD} --cacert ${ES_CA}"
                fi
                RESPONSE_HEALTH=$($RESPONSE_HEALTH_CMD)
                if [[ "$?" == "0" ]]; then
                  HTTP_CODE_CMD="curl -k --max-time 5 -s -o /dev/null -w "%{http_code}" -u $ES_AUTH $ES_URL_HEALTH"
                  if [[ "$ES_CA" != "" ]]; then
                    HTTP_CODE_CMD="${HTTP_CODE_CMD} --cacert ${ES_CA}"
                  fi
                  HTTP_CODE=$($HTTP_CODE_CMD)
                  CLUSTER_READY=$(echo \'$RESPONSE_HEALTH\' | grep -q '"status":"yellow"')
                  if [[ "$?" != "0" ]]; then
                    CLUSTER_READY=$(echo \'$RESPONSE_HEALTH\' | grep -q '"status":"green"')
                  fi
                fi
                # Status is yellow or green and http code is 200
                if [[ "$?" == "0" && "$HTTP_CODE" == "200" ]]; then
                  echo $RESPONSE_HEALTH
                  break
                else
                  echo $RESPONSE_HEALTH
                  sleep 10;
                fi
              done;

              echo "Cluster is ready to accept requests"

              if [[ -n "$token" ]]; then
                echo "Token value in secret ${K8S_SECRET_NAME} is already set, checking its validity."

                token_validity_response=$(curl -k --max-time 5 --silent --show-error \
                  -X GET \
                  -H "Authorization: Bearer $token" \
                  -H "Accept: application/json" \
                  -H "Content-Type: application/json" \
                  "$ES_URL_HEALTH" \
                )

                echo $token_validity_response

                if echo "$token_validity_response" | grep -q '"status":401'; then
                  echo "Token is invalid, recreating a new one"
                else
                  echo "Token valid, nothing to be done"
                  exit 0
                fi
              fi

              echo "Deleting previous elasticsearch token for kibana"
              DELETE_TOKEN_CMD="curl -k --max-time 5 --silent --show-error -X DELETE -u $ES_AUTH $ES_URL"
              if [[ "$ES_CA" != "" ]]; then
                DELETE_TOKEN_CMD="${DELETE_TOKEN_CMD} --cacert ${ES_CA}"
              fi
              DELETE_TOKEN=$($DELETE_TOKEN_CMD)
              echo $DELETE_TOKEN;

              echo "Creating elasticsearch token for kibana"
              CREATE_TOKEN_CMD="curl -k --max-time 5 --silent --show-error -X POST -u $ES_AUTH $ES_URL"
              if [[ "$ES_CA" != "" ]]; then
                CREATE_TOKEN_CMD="${CREATE_TOKEN_CMD} --cacert ${ES_CA}"
              fi
              CREATE_TOKEN=$($CREATE_TOKEN_CMD)

              echo "Updating kubernetes secret token"
              TOKEN=$(echo $CREATE_TOKEN | sed -n 's/.*"value":"\([^"]*\)".*/\1/p');
              BASE64_TOKEN=$(echo $TOKEN | base64 -w 0);
              K8S_SECRET=$(cat <<EOF
              {
                "metadata": {
                  "name": "{{ template "kibana.es-token" . }}"
                },
                "data": {
                  "token": "${BASE64_TOKEN}"
                }
              }
              EOF
              )
              secrets_response=$(curl -k --max-time 5 --silent --show-error \
                -X PUT \
                --cacert "$K8S_CA" \
                -H "Authorization: Bearer $K8S_BEARER" \
                -H "Accept: application/json" \
                -H "Content-Type: application/json" \
                "$K8S_URL/api/v1/namespaces/$K8S_SECRET_NAMESPACE/secrets/$K8S_SECRET_NAME" \
                -d "$K8S_SECRET")
          env:
            - name: "ELASTICSEARCH_USERNAME"
              valueFrom:
                secretKeyRef:
                  name: {{ .Values.elasticsearchCredentialSecret }}
                  key: username
            - name: "ELASTICSEARCH_PASSWORD"
              valueFrom:
                secretKeyRef:
                  name: {{ .Values.elasticsearchCredentialSecret }}
                  key: password
            - name: ELASTICSEARCH_SSL_CERTIFICATEAUTHORITIES
              value: "/certs/{{ .Values.elasticsearchCertificateAuthoritiesFile }}"
          volumeMounts:
            {{- if .Values.elasticsearchCertificateSecret }}
            - name: elasticsearch-certs
              mountPath: /certs
              readOnly: true
            {{- end }}
          {{- if .Values.preInstallJobResources }}
          resources:
            {{- toYaml .Values.preInstallJobResources | nindent 12 }}
          {{- end }}
        {{- end }}

      {{- if .Values.extraInitContainers }}
      # Currently some extra blocks accept strings
      # to continue with backwards compatibility this is being kept
      # whilst also allowing for yaml to be specified too.
      {{- if eq "string" (printf "%T" .Values.extraInitContainers) }}
{{ tpl .Values.extraInitContainers . | indent 6 }}
      {{- else }}
{{ toYaml .Values.extraInitContainers | indent 6 }}
      {{- end }}
      {{- end }}
      containers:
      - name: kibana
        securityContext:
{{ toYaml .Values.securityContext | indent 10 }}
        image: "{{ .Values.image }}:{{ .Values.imageTag }}"
        imagePullPolicy: "{{ .Values.imagePullPolicy }}"
        env:
          {{- if .Values.elasticsearchURL }}
          - name: ELASTICSEARCH_URL
            value: "{{ .Values.elasticsearchURL }}"
          {{- else if .Values.elasticsearchHosts }}
          - name: ELASTICSEARCH_HOSTS
            value: "{{ .Values.elasticsearchHosts }}"
          {{- end }}
          {{- if .Values.elasticsearchCertificateSecret }}
          - name: ELASTICSEARCH_SSL_CERTIFICATEAUTHORITIES
            value: "{{ template "kibana.home_dir" . }}/config/certs/{{ .Values.elasticsearchCertificateAuthoritiesFile }}"
          {{- end }}
          - name: SERVER_HOST
            value: "{{ .Values.serverHost }}"
          {{- if .Values.token.create }}
          - name: ELASTICSEARCH_SERVICEACCOUNTTOKEN
            valueFrom:
              secretKeyRef:
                name: {{ template "kibana.es-token" . }}
                key: token
                optional: false
          {{- end }}
{{- if .Values.extraEnvs }}
{{ toYaml .Values.extraEnvs | indent 10 }}
{{- end }}
{{- if .Values.envFrom }}
        envFrom:
{{ toYaml .Values.envFrom | indent 10 }}
{{- end }}
        readinessProbe:
{{ toYaml .Values.readinessProbe | indent 10 }}
          exec:
            command:
              - bash
              - -c
              - |
                #!/usr/bin/env bash -e

                # Disable nss cache to avoid filling dentry cache when calling curl
                # This is required with Kibana Docker using nss < 3.52
                export NSS_SDB_USE_CACHE=no

                http () {
                    local path="${1}"
                    set -- -XGET -s --fail -L

                    if [ -n "${ELASTICSEARCH_USERNAME}" ] && [ -n "${ELASTICSEARCH_PASSWORD}" ]; then
                      set -- "$@" -u "${ELASTICSEARCH_USERNAME}:${ELASTICSEARCH_PASSWORD}"
                    fi

                    STATUS=$(curl --output /dev/null --write-out "%{http_code}" -k "$@" "{{ .Values.protocol }}://localhost:{{ .Values.httpPort }}${path}")
                    if [[ "${STATUS}" -eq 200 ]]; then
                      exit 0
                    fi

                    echo "Error: Got HTTP code ${STATUS} but expected a 200"
                    exit 1
                }

                http "{{ .Values.healthCheckPath }}"
        ports:
        - containerPort: {{ .Values.httpPort }}
{{- if .Values.lifecycle }}
        lifecycle:
{{ toYaml .Values.lifecycle | indent 10 }}
{{- end }}
        resources:
{{ toYaml .Values.resources | indent 10 }}
        volumeMounts:
          {{- if .Values.elasticsearchCertificateSecret }}
          - name: elasticsearch-certs
            mountPath: {{ template "kibana.home_dir" . }}/config/certs
            readOnly: true
          {{- end }}
          - name: kibana-tokens
            mountPath: {{ template "kibana.home_dir" . }}/config/tokens
            readOnly: true
          {{- range .Values.secretMounts }}
          - name: {{ .name }}
            mountPath: {{ .path }}
            {{- if .subPath }}
            subPath: {{ .subPath }}
            {{- end }}
          {{- end }}
          {{- range $path, $config := .Values.kibanaConfig }}
          - name: kibanaconfig
            mountPath: {{ template "kibana.home_dir" . }}/config/{{ $path }}
            subPath: {{ $path }}
          {{- end -}}
        {{- if .Values.extraVolumeMounts }}
{{ toYaml .Values.extraVolumeMounts | indent 10 }}
        {{- end }}
      {{- if .Values.extraContainers }}
      # Currently some extra blocks accept strings
      # to continue with backwards compatibility this is being kept
      # whilst also allowing for yaml to be specified too.
      {{- if eq "string" (printf "%T" .Values.extraContainers) }}
{{ tpl .Values.extraContainers . | indent 6 }}
      {{- else }}
{{ toYaml .Values.extraContainers | indent 6 }}
      {{- end }}
      {{- end }}
